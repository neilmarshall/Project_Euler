"""
Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

    2^2 = 4, 2^3 = 8, 2^4 = 16, 2^5 = 32
    3^2 = 9, 3^3 = 27, 3^4 = 81, 3^5 = 243
    4^2 = =16, 4^3 = 64, 4^4 = 256, 4^5 = 1,024
    5^2 = 25, 5^3 = 125, 5^4 = 625, 5^5 = 3,125

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

    4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1,024, 3,125

How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
"""

import unittest

def get_primes(limit):
    """Return list of primes up to and including limit"""
    primes = [False, False] + [True for _ in range(2, limit + 1)]
    for p in range(2, limit // 2 + 1):
        for q in range(2, limit // p + 1):
            primes[p * q] = False
    return [i for i, p in enumerate(primes) if p]


def factorise(n):
    """Factorise number into (non-unique) primes"""
    factors = []
    for prime in get_primes(n):
        while n % prime == 0:
            factors.append(prime)
            n /= prime
    return factors


def PE_29(n):
    """Return distinct values of a^b for a, b in range [2, n]"""
    unique_numbers = set()
    for a in range(2, n + 1):
        factors = factorise(a)
        for b in range(2, n + 1):
            power = tuple(sorted(factors * b))
            unique_numbers.add(power)
    return len(unique_numbers)


class TestPE29(unittest.TestCase):
    def test_5_returns_15(self):
        self.assertEqual(PE_29(5), 15)

    def test_100_returns_9183(self):
        self.assertEqual(PE_29(100), 9183)


if __name__ == '__main__':
    unittest.main()

/*
Triangle, pentagonal, and hexagonal numbers are generated by the following
formulae:

    Triangle    Tn = n(n + 1) / 2	 	1, 3, 6, 10, 15, ...
    Pentagonal  Pn = n(3n − 1) / 2	 	1, 5, 12, 22, 35, ...
    Hexagonal   Hn = n(2n − 1)  	 	1, 6, 15, 28, 45, ...

It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.

NOTES:

    1. The generating functions can be restated as follows:

            0.5n^2 + 0.5n
            1.5n^2 - 0.5n
            2n^2 - n

    2. From this we can see that T << P << H for large n

    3. So iterate through all numbers keeping a record of observed pentagonal
       and hexagonal numbers, returning the third occurrence of a triangle
       number that lies in both sets of observed numbers (third occurrence
       since the first and second are 1 and 40755 respectively)

SOLUTION = 1,533,776,805 - v1 took 161 seconds
SOLUTION = 1,533,776,805 - v2 (current version) took 0.1 seconds
*/

#include <iostream>
#include <set>

inline long triangle(long n) { return n * (n + 1) / 2; }

inline long pentagon(long n) { return n * (3 * n - 1) / 2; }

inline long hexagon(long n) { return n * (2 * n - 1); }

long get_nth_solution(long solution_occurrence) {

    long solution_count = 0;

    std::set<long> pentagonnumbers;
    std::set<long> hexagonnumbers;

    long n = 0;
    while (++n) {
        pentagonnumbers.insert(pentagon(n));
        hexagonnumbers.insert(hexagon(n));
        if (pentagonnumbers.find(triangle(n)) != pentagonnumbers.end() &&
            hexagonnumbers.find(triangle(n)) != hexagonnumbers.end()) {
            solution_count += 1;
            if (solution_count == solution_occurrence)
                return triangle(n);
        }
    }
}

int main() {

	std::cout << get_nth_solution(3) << std::endl;

}

